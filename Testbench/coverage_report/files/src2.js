var g_data = {"name":"APB_coverage.py","src":"from common_imports import *\r\nfrom APB_seq_item_vsc import *\r\n\r\n@vsc.covergroup\r\nclass APBCoverGroup(object):\r\n    def __init__(self):\r\n        self.with_sample(\r\n            PRESETn=vsc.bit_t(1),\r\n            PWRITE=vsc.bit_t(1),\r\n            PENABLE=vsc.bit_t(1),\r\n            PREADY=vsc.bit_t(1),\r\n            PADDR=vsc.uint32_t(),\r\n            PWDATA=vsc.uint32_t(),\r\n            PRDATA=vsc.uint32_t()\r\n        )\r\n\r\n        # Reset state coverage\r\n        self.cp_preset = vsc.coverpoint(self.PRESETn, bins=dict(\r\n            reset_active=vsc.bin(0),\r\n            reset_inactive=vsc.bin(1)\r\n        ))\r\n\r\n        # Transfer type coverage\r\n        self.cp_pwrite = vsc.coverpoint(self.PWRITE, bins=dict(\r\n            read=vsc.bin(0),\r\n            write=vsc.bin(1)\r\n        ))\r\n\r\n        # Enable signal coverage\r\n        self.cp_penable = vsc.coverpoint(self.PENABLE, bins=dict(\r\n            enabled=vsc.bin(1),\r\n            disabled=vsc.bin(0)\r\n        ))\r\n\r\n        # Address coverage - 16 possible addresses (0x0 to 0x3C in steps of 4)\r\n        addr_values = [i*4 for i in range(16)]\r\n        self.cp_paddr = vsc.coverpoint(self.PADDR, bins=dict(\r\n            [(f\"addr_{hex(addr)}\", vsc.bin(addr)) for addr in addr_values]\r\n        ))\r\n\r\n        # Write data coverage (corrected range specification)\r\n        self.cp_pwdata = vsc.coverpoint(self.PWDATA, bins=dict(\r\n            zero=vsc.bin(0),\r\n            all_ones=vsc.bin(0xFFFFFFFF)\r\n        ))\r\n\r\n        # Cross coverage between key signals\r\n        self.cross_rw_addr  = vsc.cross([self.cp_pwrite, self.cp_paddr])\r\n        self.cross_rw_wdata = vsc.cross([self.cp_pwrite, self.cp_pwdata])\r\n\r\nclass APB_coverage(uvm_component):\r\n    def build_phase(self):\r\n        self.cov_fifo = uvm_tlm_analysis_fifo(\"cov_fifo\", self)\r\n        self.cov_get_port = uvm_get_port(\"cov_get_port\", self)\r\n        self.cov_export = self.cov_fifo.analysis_export\r\n        self.cg = APBCoverGroup()\r\n\r\n    def connect_phase(self):\r\n        self.cov_get_port.connect(self.cov_fifo.get_export)\r\n\r\n    async def run_phase(self):\r\n        while True:\r\n            try:\r\n                item = await self.cov_get_port.get()\r\n                self.cg.sample(\r\n                    item.PRESETn,\r\n                    item.PWRITE,\r\n                    item.PENABLE,\r\n                    item.PREADY,\r\n                    item.PADDR,\r\n                    item.PWDATA,\r\n                    item.PRDATA\r\n                )\r\n                self.logger.debug(f\"{self.get_type_name()}: SAMPLED {item}\")\r\n                self.logger.debug(f\"Instance Coverage = {self.cg.get_inst_coverage()}\")\r\n            except Exception as e:\r\n                pass\r\n\r\n    def report_phase(self):\r\n        self.logger.info(\"cg total coverage=%f\" % (self.cg.get_coverage()))\r\n        vsc.report_coverage(details=False)\r\n        vsc.write_coverage_db(filename=\"apb_coverage.xml\",  fmt='xml',      libucis=None)\r\n        vsc.write_coverage_db(filename=\"apb_coverage.ucdb\", fmt='libucis',  libucis=\"/home/amrelbatarny/QuestaSim/questasim/linux_x86_64/libucis.so\")","lang":"unk"};
processSrcData(g_data);