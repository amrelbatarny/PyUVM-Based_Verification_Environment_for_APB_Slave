var g_data = {"name":"Coverage.py","src":"import vsc\r\nfrom vsc import (\r\n    covergroup,          # covergroup decorator\r\n    uint32_t,            # for 32-bit unsigned samples\r\n    bit_t,               # for fixed-width bit samples\r\n    enum_t,              # for sampling enums\r\n    coverpoint,          # to declare coverpoints\r\n    cross,               # for cross-coverage\r\n    bin as vsc_bin,      # bin definitions\r\n    report_coverage,     # print summary coverage report\r\n    write_coverage_db,   # save coverage to XML or UCIS DB\r\n)\r\nfrom pyuvm import (\r\n    uvm_component,            # base class for UVM components\r\n    uvm_tlm_analysis_fifo,    # to collect transactions\r\n    uvm_get_port,             # to receive transactions\r\n)\r\nfrom APB_utils import APBType # your APBType enum\r\n\r\n@vsc.covergroup\r\nclass ApbCoverGroup(object):\r\n    def __init__(self):\r\n        self.with_sample(\r\n            addr=vsc.uint32_t(),\r\n            data=vsc.uint32_t(),\r\n            strobe=vsc.bit_t(4),\r\n            type=vsc.enum_t(APBType)\r\n        )\r\n\r\n        # Transfer type coverage\r\n        self.cp_pwrite = vsc.coverpoint(self.type, bins=dict(\r\n            read=vsc.bin(APBType.READ),\r\n            write=vsc.bin(APBType.WRITE)\r\n        ))\r\n\r\n        # Address coverage - 16 possible addresses (0x0 to 0x3C in steps of 4)\r\n        addr_values = [i*4 for i in range(16)]\r\n        self.cp_paddr = vsc.coverpoint(self.addr, bins=dict(\r\n            [(f\"address_{hex(address)}\", vsc.bin(address)) for address in addr_values]\r\n        ))\r\n\r\n        # Write data coverage (corrected range specification)\r\n        self.cp_pwdata = vsc.coverpoint(self.data, bins=dict(\r\n            zero=vsc.bin(0),\r\n            all_ones=vsc.bin(0xFFFFFFFF)\r\n        ))\r\n\r\n        # Cross coverage between key signals\r\n        self.cross_rw_addr  = vsc.cross([self.cp_pwrite, self.cp_paddr])\r\n        self.cross_rw_wdata = vsc.cross([self.cp_pwrite, self.cp_pwdata])\r\n\r\nclass ApbCoverage(uvm_component):\r\n    def build_phase(self):\r\n        self.cov_fifo = uvm_tlm_analysis_fifo(\"cov_fifo\", self)\r\n        self.cov_get_port = uvm_get_port(\"cov_get_port\", self)\r\n        self.cov_export = self.cov_fifo.analysis_export\r\n        self.cg = ApbCoverGroup()\r\n\r\n    def connect_phase(self):\r\n        self.cov_get_port.connect(self.cov_fifo.get_export)\r\n\r\n    async def run_phase(self):\r\n        while True:\r\n            try:\r\n                item = await self.cov_get_port.get()\r\n                self.cg.sample(\r\n                    item.addr,\r\n                    item.data,\r\n                    item.strobe,\r\n                    item.type\r\n                )\r\n                self.logger.debug(f\"{self.get_type_name()}: SAMPLED {item}\")\r\n                self.logger.debug(f\"Instance Coverage = {self.cg.get_inst_coverage()}\")\r\n            except Exception as e:\r\n                pass\r\n\r\n    def report_phase(self):\r\n        self.logger.info(\"cg total coverage=%f\" % (self.cg.get_coverage()))\r\n        vsc.report_coverage(details=False)\r\n        vsc.write_coverage_db(filename=\"../Coverage_Reports/Exported_by_PyVSC/apb_coverage.xml\",  fmt='xml',      libucis=None)\r\n        vsc.write_coverage_db(filename=\"../Coverage_Reports/Exported_by_PyVSC/apb_coverage.ucdb\", fmt='libucis',  libucis=\"/home/amrelbatarny/QuestaSim/questasim/linux_x86_64/libucis.so\")","lang":"unk"};
processSrcData(g_data);