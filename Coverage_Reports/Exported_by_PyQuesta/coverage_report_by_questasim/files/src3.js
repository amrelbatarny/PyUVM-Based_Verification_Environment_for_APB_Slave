var g_data = {"name":"../RTL/RegisterFile.sv","src":"module RegisterFile #(\n	parameter DATA_WIDTH	= 32,\n	parameter ADDR_WIDTH	= 32,\n	parameter NBYTES		= DATA_WIDTH/8\n	)(\n	input wire 							clk,\n	input wire 							rst_n,\n	input wire [ADDR_WIDTH-1 : 0]		addr,\n	input wire							read_en,\n	input wire							write_en,\n	input wire [NBYTES-1:0]				byte_strobe,\n	input wire [DATA_WIDTH-1 : 0]		wdata,\n	output reg [DATA_WIDTH-1 : 0]		rdata\n	);\n\n	// Registers\n	reg [DATA_WIDTH-1:0] SYS_STATUS_REG;\n	reg [DATA_WIDTH-1:0] INT_CTRL_REG;\n	reg [DATA_WIDTH-1:0] DEV_ID_REG;\n	reg [DATA_WIDTH-1:0] MEM_CTRL_REG;\n	reg [DATA_WIDTH-1:0] TEMP_SENSOR_REG;\n	reg [DATA_WIDTH-1:0] ADC_CTRL_REG;\n	reg [DATA_WIDTH-1:0] DBG_CTRL_REG;\n	reg [DATA_WIDTH-1:0] GPIO_DATA_REG;\n	reg [DATA_WIDTH-1:0] DAC_OUTPUT_REG;\n	reg [DATA_WIDTH-1:0] VOLTAGE_CTRL_REG;\n	reg [DATA_WIDTH-1:0] CLK_CONFIG_REG;\n	reg [DATA_WIDTH-1:0] TIMER_COUNT_REG;\n	reg [DATA_WIDTH-1:0] INPUT_DATA_REG;\n	reg [DATA_WIDTH-1:0] OUTPUT_DATA_REG;\n	reg [DATA_WIDTH-1:0] DMA_CTRL_REG;\n	reg [DATA_WIDTH-1:0] SYS_CTRL_REG;\n\n	wire [DATA_WIDTH-1:0] mask;\n	genvar i;\n	generate\n		for (i = 0; i < NBYTES; i = i + 1) begin\n			// replicate byte_strobe[i] across 8 bits\n			assign mask[(i+1)*8-1 -: 8] = {8{byte_strobe[i]}};\n		end\n	endgenerate\n\n\n	always @(posedge clk or negedge rst_n) begin\n		if(~rst_n)\n			rdata <= 0;\n		else begin\n			if(write_en)\n				case (addr)\n					32'h0000_0000: SYS_STATUS_REG	<= (SYS_STATUS_REG		&	~mask) | (wdata & mask);\n					32'h0000_0004: INT_CTRL_REG		<= (INT_CTRL_REG		&	~mask) | (wdata & mask);\n					32'h0000_0008: DEV_ID_REG		<= (DEV_ID_REG			&	~mask) | (wdata & mask);\n					32'h0000_000c: MEM_CTRL_REG		<= (MEM_CTRL_REG		&	~mask) | (wdata & mask);\n					32'h0000_0010: TEMP_SENSOR_REG	<= (TEMP_SENSOR_REG		&	~mask) | (wdata & mask);\n					32'h0000_0014: ADC_CTRL_REG		<= (ADC_CTRL_REG		&	~mask) | (wdata & mask);\n					32'h0000_0018: DBG_CTRL_REG		<= (DBG_CTRL_REG		&	~mask) | (wdata & mask);\n					32'h0000_001c: GPIO_DATA_REG	<= (GPIO_DATA_REG		&	~mask) | (wdata & mask);\n					32'h0000_0020: DAC_OUTPUT_REG	<= (DAC_OUTPUT_REG		&	~mask) | (wdata & mask);\n					32'h0000_0024: VOLTAGE_CTRL_REG	<= (VOLTAGE_CTRL_REG	&	~mask) | (wdata & mask);\n					32'h0000_0028: CLK_CONFIG_REG	<= (CLK_CONFIG_REG		&	~mask) | (wdata & mask);\n					32'h0000_002c: TIMER_COUNT_REG	<= (TIMER_COUNT_REG		&	~mask) | (wdata & mask);\n					32'h0000_0030: INPUT_DATA_REG	<= (INPUT_DATA_REG		&	~mask) | (wdata & mask);\n					32'h0000_0034: OUTPUT_DATA_REG	<= (OUTPUT_DATA_REG		&	~mask) | (wdata & mask);\n					32'h0000_0038: DMA_CTRL_REG		<= (DMA_CTRL_REG		&	~mask) | (wdata & mask);\n					32'h0000_003c: SYS_CTRL_REG		<= (SYS_CTRL_REG		&	~mask) | (wdata & mask);\n				endcase\n			if(read_en)\n				case (addr)\n					32'h0000_0000: rdata <= SYS_STATUS_REG;\n					32'h0000_0004: rdata <= INT_CTRL_REG;\n					32'h0000_0008: rdata <= DEV_ID_REG;\n					32'h0000_000c: rdata <= MEM_CTRL_REG;\n					32'h0000_0010: rdata <= TEMP_SENSOR_REG;\n					32'h0000_0014: rdata <= ADC_CTRL_REG;\n					32'h0000_0018: rdata <= DBG_CTRL_REG;\n					32'h0000_001c: rdata <= GPIO_DATA_REG;\n					32'h0000_0020: rdata <= DAC_OUTPUT_REG;\n					32'h0000_0024: rdata <= VOLTAGE_CTRL_REG;\n					32'h0000_0028: rdata <= CLK_CONFIG_REG;\n					32'h0000_002c: rdata <= TIMER_COUNT_REG;\n					32'h0000_0030: rdata <= INPUT_DATA_REG;\n					32'h0000_0034: rdata <= OUTPUT_DATA_REG;\n					32'h0000_0038: rdata <= DMA_CTRL_REG;\n					32'h0000_003c: rdata <= SYS_CTRL_REG;\n				endcase\n        end\n	end\nendmodule","lang":"verilog"};
processSrcData(g_data);